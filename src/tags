!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
CFLAG	Makefile	/^CFLAG = -O2 -static -fopenmp -std=c++11$/;"	m
FULL	util.h	/^        enum TimeType { FULL, PARTIAL };$/;"	e	enum:util::TimeUsage::TimeType
GaussianSmooth	util.h	/^    class GaussianSmooth$/;"	c	namespace:util
INOUT	util.h	/^    enum PinDir { UNKNOWN, INPUT, OUTPUT, INOUT };$/;"	e	enum:util::PinDir
INPUT	util.h	/^    enum PinDir { UNKNOWN, INPUT, OUTPUT, INOUT };$/;"	e	enum:util::PinDir
MAX_DOUBLE	util.h	24;"	d
MAX_INT	util.h	22;"	d
MAX_SIZE_T	util.h	23;"	d
MAX_UNSIGNED	util.h	21;"	d
MEMORY_SCALE	util.h	66;"	d
MIN_DOUBLE	util.h	25;"	d
OBJECTS	Makefile	/^OBJECTS = main.o$/;"	m
OR_E	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_FE	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_FN	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_FS	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_FW	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_N	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_OTHER	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_S	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OR_W	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	e	enum:util::Orient
OUTPUT	util.h	/^    enum PinDir { UNKNOWN, INPUT, OUTPUT, INOUT };$/;"	e	enum:util::PinDir
Orient	util.h	/^    enum Orient {OR_N, OR_W, OR_S, OR_E, OR_FN, OR_FW, OR_FS, OR_FE, OR_OTHER};$/;"	g	namespace:util
PARTIAL	util.h	/^        enum TimeType { FULL, PARTIAL };$/;"	e	enum:util::TimeUsage::TimeType
PI	util.h	/^        const double PI = M_PI;$/;"	m	class:util::GaussianSmooth
PinDir	util.h	/^    enum PinDir { UNKNOWN, INPUT, OUTPUT, INOUT };$/;"	g	namespace:util
Point	util.h	/^        Point(double x=MAX_DOUBLE, double y=MAX_DOUBLE):_x(x), _y(y) {}$/;"	f	class:util::Point
Point	util.h	/^    class Point$/;"	c	namespace:util
Rect	util.h	/^        Rect( const Rect &r ): _left(r.left()), _bottom(r.bottom()), _right(r.right()), _top(r.top()) {}$/;"	f	class:util::Rect
Rect	util.h	/^        Rect(double left = 0, double bottom = 0, double right = 0, double top = 0)$/;"	f	class:util::Rect
Rect	util.h	/^    class Rect$/;"	c	namespace:util
TARGET	Makefile	/^TARGET = ..\/bin\/rt$/;"	m
TIME_SCALE	util.h	65;"	d
TimeState	util.h	/^            TimeState( long r=0, long u=0, long s=0 ): rTime(r), uTime(u), sTime(s) {}$/;"	f	struct:util::TimeUsage::TimeState
TimeState	util.h	/^        struct TimeState{$/;"	s	class:util::TimeUsage
TimeType	util.h	/^        enum TimeType { FULL, PARTIAL };$/;"	g	class:util::TimeUsage
TimeUsage	util.h	/^        TimeUsage() { start( FULL ); start( PARTIAL ); }$/;"	f	class:util::TimeUsage
TimeUsage	util.h	/^    class TimeUsage{$/;"	c	namespace:util
UNKNOWN	util.h	/^    enum PinDir { UNKNOWN, INPUT, OUTPUT, INOUT };$/;"	e	enum:util::PinDir
UTIL_H	util.h	2;"	d
_bottom	util.h	/^        double _bottom;$/;"	m	class:util::Rect
_left	util.h	/^        double _left;$/;"	m	class:util::Rect
_right	util.h	/^        double _right;$/;"	m	class:util::Rect
_top	util.h	/^        double _top;$/;"	m	class:util::Rect
_x	util.h	/^        double _x, _y;$/;"	m	class:util::Point
_xDim	util.h	/^        size_t _xDim, _yDim;$/;"	m	class:util::vector2D
_y	util.h	/^        double _x, _y;$/;"	m	class:util::Point
_yDim	util.h	/^        size_t _xDim, _yDim;$/;"	m	class:util::vector2D
area	util.h	/^        double area() const {return width() * height(); }$/;"	f	class:util::Rect
bool2Str	util.h	/^    inline string bool2Str( bool isTrue ){$/;"	f	namespace:util
bottom	util.h	/^        double bottom() const {return _bottom;}$/;"	f	class:util::Rect
boundPosition	util.h	/^        void boundPosition( double &x, double &y ){$/;"	f	class:util::Rect
center	util.h	/^        Point center() const {return Point(centerX(), centerY());}$/;"	f	class:util::Rect
centerX	util.h	/^        double centerX() const {return (_left + _right)\/2;}$/;"	f	class:util::Rect
centerY	util.h	/^        double centerY() const {return (_bottom + _top)\/2;}$/;"	f	class:util::Rect
checkUsage	util.h	/^        void checkUsage( TimeState &st ) const {$/;"	f	class:util::TimeUsage
delete_values	util.h	/^        void delete_values() { delete [] value; }$/;"	f	class:util::vector2D
diff	util.h	/^        TimeState diff( TimeState &start, TimeState &end ){$/;"	f	class:util::TimeUsage
dir2Str	util.h	/^    inline string dir2Str( PinDir pinDir ){$/;"	f	namespace:util
dist	util.h	/^        static double dist(const Point &p1, const Point &p2){$/;"	f	class:util::Point
gaussian_discrete_2D	util.cpp	/^double util::GaussianSmooth::gaussian_discrete_2D(double theta, int x, int y)$/;"	f	class:util::GaussianSmooth
getFileDirname	util.h	/^    inline string getFileDirname(const string &filePathName){$/;"	f	namespace:util
getFileName	util.h	/^    inline string getFileName(const string &filePathName){$/;"	f	namespace:util
getPeakMemoryUsage	util.h	/^    inline double getPeakMemoryUsage(){$/;"	f	namespace:util
height	util.h	/^        double height() const {return _top - _bottom;}$/;"	f	class:util::Rect
init	util.h	/^        void init( size_t xDim, size_t yDim, T t ){$/;"	f	class:util::vector2D
init_gaussian_2D	util.cpp	/^void util::GaussianSmooth::init_gaussian_2D(double theta, int size)$/;"	f	class:util::GaussianSmooth
interpolate	util.h	/^    inline double interpolate( const double &a, const double &b, const double &ratio ){$/;"	f	namespace:util
is_char_special	util.cpp	/^bool util::is_char_special(char c)$/;"	f	class:util
is_equal	util.h	/^    inline bool is_equal( double a, double b, double accuracy = 0.000001 ){$/;"	f	namespace:util
is_less	util.h	/^    inline bool is_less ( double a, double b, double accuracy = 0.000001 ){$/;"	f	namespace:util
left	util.h	/^        double left() const {return _left;}$/;"	f	class:util::Rect
length	util.h	/^        static double length(const Point &p){$/;"	f	class:util::Point
m_kernel	util.h	/^        vector< vector< double> > m_kernel;$/;"	m	class:util::GaussianSmooth
main	main.cpp	/^int main( int argc, char **argv )$/;"	f
num2str	util.h	/^    template <class T> inline string num2str(const T &p ){$/;"	f	namespace:util
operator !=	util.h	/^        bool operator != (const Point &p){$/;"	f	class:util::Point
operator ()	util.h	/^        T &operator () ( const size_t &xId, const size_t &yId ) const {$/;"	f	class:util::vector2D
operator +	util.h	/^        Point operator + (const Point &p){$/;"	f	class:util::Point
operator -	util.h	/^        Point operator - (const Point &p){$/;"	f	class:util::Point
operator <<	util.h	/^    inline ostream &operator << (ostream& out, const Point& p){$/;"	f	namespace:util
operator <<	util.h	/^    inline ostream& operator << (ostream& out, const Rect& rect){$/;"	f	namespace:util
operator =	util.h	/^        const vector2D& operator=( const vector2D& rVec){$/;"	f	class:util::vector2D
operator =	util.h	/^        void operator = (const Point &p){$/;"	f	class:util::Point
operator =	util.h	/^        void operator = (const Rect &rect){$/;"	f	class:util::Rect
operator ==	util.h	/^        bool operator == (const Point &p){$/;"	f	class:util::Point
operator ==	util.h	/^    inline bool operator ==(const Rect &r1, const Rect &r2){$/;"	f	namespace:util
orientStr	util.h	/^    inline string orientStr( Orient orient ) {$/;"	f	namespace:util
overlapArea	util.h	/^        static double overlapArea(const Rect &rect1, const Rect &rect2) {$/;"	f	class:util::Rect
pStart_	util.h	/^        TimeState tStart_, pStart_; \/\/total, period$/;"	m	class:util::TimeUsage
rTime	util.h	/^            long rTime, uTime, sTime; \/\/real, user, system$/;"	m	struct:util::TimeUsage::TimeState
read_line_2_tokens	util.cpp	/^bool util::read_line_2_tokens(istream &inFile, vector<string> &tokens){$/;"	f	class:util
right	util.h	/^        double right() const {return _right;}$/;"	f	class:util::Rect
round	util.h	/^        void round(){$/;"	f	class:util::Rect
round_me	util.h	/^    inline void round_me( double &a, double accuracy = 0.0001 ){$/;"	f	namespace:util
sTime	util.h	/^            long rTime, uTime, sTime; \/\/real, user, system$/;"	m	struct:util::TimeUsage::TimeState
scale	util.h	/^        Rect scale(double s) const {return Rect( _left*s, _bottom*s, _right*s, _top*s );}$/;"	f	class:util::Rect
scale	util.h	/^        void scale( const double &s ){$/;"	f	class:util::Point
scale	util.h	/^        void scale(const double &sx, const double &sy ){$/;"	f	class:util::Point
scale_me	util.h	/^        void scale_me(double s) {_left*=s; _bottom*=s; _right*=s; _top*=s;}$/;"	f	class:util::Rect
setBottom	util.h	/^        void setBottom(const double & bottom){$/;"	f	class:util::Rect
setBounds	util.h	/^        void setBounds(const double & left, const double & bottom, const double & right, const double & top) {$/;"	f	class:util::Rect
setLeft	util.h	/^        void setLeft(const double & left){$/;"	f	class:util::Rect
setRight	util.h	/^        void setRight(const double & right){$/;"	f	class:util::Rect
setTop	util.h	/^        void setTop(const double &top){$/;"	f	class:util::Rect
set_x_y	util.h	/^        void set_x_y(const double &x, const double &y){$/;"	f	class:util::Point
shift	util.h	/^        Rect shift(const Point &p) const {return Rect( _left+p.x(), _bottom+p.y(), _right+p.x(), _top+p.y() );}$/;"	f	class:util::Rect
shift	util.h	/^        Rect shift(double x, double y) const {return Rect( _left+x, _bottom+y, _right+x, _top+y );}$/;"	f	class:util::Rect
shift	util.h	/^        void shift(const double &x, const double &y){$/;"	f	class:util::Point
shift_and_scale_me	util.h	/^        void shift_and_scale_me( const Point &p, const double &s, bool isBack = false ){$/;"	f	class:util::Rect
shift_me	util.h	/^        void shift_me(const Point &p) {_left+=p.x(); _bottom+=p.y(); _right+=p.x(); _top+=p.y();}$/;"	f	class:util::Rect
shift_scale	util.h	/^        void shift_scale( const Point &sh, const double& sc, bool isBack ){$/;"	f	class:util::Point
showSysInfoComdLine	util.h	/^    inline void showSysInfoComdLine( int argc, char *argv[] ){$/;"	f	namespace:util
showUsage	util.h	/^        void showUsage( const string comment, TimeType type ){$/;"	f	class:util::TimeUsage
smooth	util.cpp	/^void util::GaussianSmooth::smooth(vector<vector<double> > &input)$/;"	f	class:util::GaussianSmooth
smoothing_vec2D	util.cpp	/^void util::smoothing_vec2D(vector2D<double> &vec2D)$/;"	f	class:util
start	util.h	/^        void start( TimeType type ){ ( type==FULL ) ? checkUsage( tStart_ ) : checkUsage( pStart_ ); }$/;"	f	class:util::TimeUsage
stl_to_vec2D	util.h	/^    void stl_to_vec2D( vector<vector<T> > &v, vector2D<T> &v2D ){$/;"	f	namespace:util
tStart_	util.h	/^        TimeState tStart_, pStart_; \/\/total, period$/;"	m	class:util::TimeUsage
top	util.h	/^        double top() const {return _top;}$/;"	f	class:util::Rect
uTime	util.h	/^            long rTime, uTime, sTime; \/\/real, user, system$/;"	m	struct:util::TimeUsage::TimeState
util	util.h	/^namespace util$/;"	n
value	util.h	/^        T *value;$/;"	m	class:util::vector2D
vec2D_to_stl	util.h	/^    void vec2D_to_stl( vector2D<T> &v2D, vector<vector<T> > &v ){$/;"	f	namespace:util
vector2D	util.h	/^        vector2D( size_t xDim, size_t yDim, T t ){ value = NULL; init( xDim, yDim, t ); }$/;"	f	class:util::vector2D
vector2D	util.h	/^        vector2D():_xDim(0), _yDim(0), value(NULL) {}$/;"	f	class:util::vector2D
vector2D	util.h	/^    class vector2D{$/;"	c	namespace:util
width	util.h	/^        double width() const {return _right - _left;}$/;"	f	class:util::Rect
x	util.h	/^        double x() const {return _x;}$/;"	f	class:util::Point
xDim	util.h	/^        int xDim() {return _xDim;}$/;"	f	class:util::vector2D
y	util.h	/^        double y() const {return _y;}$/;"	f	class:util::Point
yDim	util.h	/^        int yDim() {return _yDim;}$/;"	f	class:util::vector2D
~vector2D	util.h	/^        ~vector2D() { delete_values(); }$/;"	f	class:util::vector2D
